{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"TP%20tris_correction/","text":"NSI Sp\u00e9cialit\u00e9 NSI Premi\u00e8re - J.J.Dides nov.2021 - S.Roux janv.2022 Algorithmes de tris Dans ce notebook nous allons impl\u00e9menter en Python, les deux algorithmes de tris vus en cours : le tri par s\u00e9lection et le tri par insertion Tri par S\u00e9lection Le tri par s\u00e9lection parcours la liste de la gauche vers la droite, en maintenant sur la gauche une partie de la liste d\u00e9j\u00e0 tri\u00e9e et o\u00f9 les \u00e9l\u00e9ments sont rang\u00e9s \u00e0 leur place d\u00e9finitive. A chaque \u00e9tape, on cherche le plus petit \u00e9l\u00e9ment dans la partie de droite non tri\u00e9e de la liste, puis on l'\u00e9change avec l'\u00e9l\u00e9ment le plus \u00e0 gauche de cette partie non tri\u00e9e : Pour impl\u00e9menter en Python cet algorithme, nous allons nous aider de l'algorithme construit en cours et diviser les diff\u00e9rentes \u00e9tapes en plusieurs fonctions . \u270e Application Ecrire une fonction minimum(T, a) qui retourne le rang du plus petit \u00e9l\u00e9ment de la liste T entre l'\u00e9l\u00e9ment d'indice a et le dernier \u00e9l\u00e9ment de la liste (inclus). Puis testez-la avec les listes cr\u00e9es ci-dessous def minimum(T, a) : # \u00e0 remplir if len(T) == 0 : return None imini = a for i in range(a+1,len(T)) : if T[i] < T[imini] : imini = i return imini # tests l1 = [3,2,9,6,8,1] l2 = [-2,0,5,7] l3 = [] print(minimum(l1,0)) print(minimum(l2,0)) print(minimum(l3,0)) 5 0 None \u270e Application Ecrire une fonction echange(T, a, b) qui permute dans la liste T les \u00e9l\u00e9ments d'indice a et b . Puis testez-la avec des nouvelles listes ou celles cr\u00e9es au-dessus. def echange(T, a, b) : # \u00e0 remplir T[a], T[b] = T[b], T[a] return T # tests print(echange(l1,0,5)) [1, 2, 9, 6, 8, 3] \u270e Application Ecrire maintenant la fonction tri_selection(T) qui effectue le tri de la liste T par s\u00e9lection, en suivant l'algorithme \u00e9crit dans le cours et en utilisant les 2 fonctions minimum() et echange() . def tri_selection(T) : # \u00e0 remplir for i in range(len(T)) : imini = minimum(T,i) echange(T,imini,i) return T Tester cette fonction sur la liste T suivante : # Soit la liste suivante (10 \u00e9l\u00e9ments entiers) \u00e0 trier T = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] tri_selection(T) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25] Quelle est la complexit\u00e9 de l'algorithme de tri par s\u00e9lection Essayons de mesurer la dur\u00e9e d'un tri par s\u00e9lection. On fait varier la taille n de la liste T de 0 \u00e0 5000 et on stocke dans une liste les dur\u00e9es d'ex\u00e9cution de la fonction tri_selection(T) en milliseconde, mesur\u00e9es \u00e0 l'aide la la fonction perfcounter() du module time, qui retourne un temps en secondes : import matplotlib.pyplot as plt from time import perf_counter X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [i for i in range(2,n)] # cr\u00e9ation d'un tableau d\u00e9sordonn\u00e9 de n entiers T.append(1) debut = perf_counter() # mesure du temps avant et apr\u00e8s tri de T tri_selection(T) fin = perf_counter() X.append(n) # construction des listes des valeurs de n et T(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) # trac\u00e9 de la courbe de variation de T(n) en fonction de n plt.show() On constate, au premier abord que l'ex\u00e9cution du script prend un temps significatif. On observe ensuite, sur la courbe obtenue, qu'un doublement de la longueur du tableau, multiplie sa dur\u00e9e de tri par 4 ! Plus rigoureusement, pour \u00e9valuer la performance d'un algorithme de tri, on peut compter, par exemple, le nombre de comparaisons de 2 \u00e9l\u00e9ments de la liste. Si la liste comprend n \u00e9l\u00e9ments et que, dans le pire des cas, le d\u00e9sordre initial est total, il faudra, pour ordonner l'ensemble du tableau : $(n-1) + (n-2) + (n-3) + ... + 2 + 1 = n * (n-1) / 2 = n^2 / 2 - n / 2$ comparaisons En effet, ce tri implique 2 boucles imbriqu\u00e9es : * la boucle for de la fonction tri_selection() qui parcours la liste du d\u00e9but \u00e0 la fin (n it\u00e9rations) * la boucle for de la fonction minimum() qui recherche le minimum d'une liste de (n-i it\u00e9rations) Vous pouvez copier le code de votre fonction minimum() \u00e0 la place de son appel dans la fonction tri_selection() pour mieux voir les boucles imbriqu\u00e9es. Ce qui confirme que le tri par s\u00e9lection est de **complexit\u00e9 quadratique** $O(n^2)$ ! Pour rappel, voici les courbes des fonctions $f(n) = n$ (complexit\u00e9 lin\u00e9aire) et $f(n) = n^2$ (complexit\u00e9 quadratique) : X = [i for i in range(0,10)] YL = [i for i in range(0,10)] YQ = [i**2 for i in range(0,10)] plt.close() plt.plot(X, YL, YQ) plt.show() Tri par Insertion Le tri par insertion parcours lui aussi la liste de la gauche vers la droite, en construisant sur la gauche une partie de la liste d\u00e9j\u00e0 tri\u00e9e. On va, \u00e0 chaque \u00e9tape, ins\u00e9rer le premier \u00e9l\u00e9ment non encore tri\u00e9 parmi les \u00e9l\u00e9ments situ\u00e9s \u00e0 sa gauche et d\u00e9j\u00e0 tri\u00e9s. Les **slices** sont des expressions du langage Python qui vous permettent en une ligne de code d\u2019extraire des \u00e9l\u00e9ments d\u2019une liste ou d\u2019une cha\u00eene de caract\u00e8res. Exemples avec ``liste = [3,54,34,27,2,90]`` * ``liste[a:b]`` ==> correspond \u00e0 la sous-liste des \u00e9l\u00e9ments d'indice a \u00e0 b-1 * ``liste[0:3]`` ==> vaut ``[3, 54, 34]`` Pour impl\u00e9menter en Python cet algorithme : Il faut disposer d'une fonction insere(liste, i) qui ins\u00e8re l'\u00e9l\u00e9ment d'indice i ( liste[i] ) \u00e0 la bonne blace dans la liste tri\u00e9e liste[0:i] . Pour cela on compare liste[i] aux \u00e9l\u00e9ments tri\u00e9s de liste[0:i] qui le pr\u00e9c\u00e8dent. On rep\u00e8re le premier \u00e9l\u00e9ment liste[j] plus grand que liste[i] , d\u00e9caler les \u00e9l\u00e9ments de liste[j:i] plus grands que liste[i] d'une position vers la droite et placer liste[i] \u00e0 la position j ainsi lib\u00e9r\u00e9e. liste[i] sera d\u00e9plac\u00e9 \u00e0 une position qui conserve l'ordre croissant des \u00e9l\u00e9ments de liste[0:i+1] \u270e Application Compl\u00e9ter la fonction insere(liste, i) qui ins\u00e8re l'\u00e9l\u00e9ment d'indice i \u00e0 la bonne blace dans la partie de liste tri\u00e9e. Cette fonction retourne la liste apr\u00e8s les modifications. Puis testez-la avec les jeux de tests en dessous. def insere(liste, i) : # tant que T[i] n'est pas \u00e0 la bonne place dans T[0:i], on echange sa valeur avec celle de l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent. while i > 0 and liste[i] < liste[i-1] : liste[i], liste[i-1] = liste[i-1], liste[i] i -= 1 return liste l2 = [0,3,4,5,2,9] assert insere(l2,4) == [0, 2, 3, 4, 5, 9] l3 = [4,5,6,8,9,0,1] assert insere(l3, 5) == [0, 4, 5, 6, 8, 9, 1] assert insere(l3, 6) == [0, 1, 4, 5, 6, 8, 9] \u270e Application Ecrire la fonction tri_insertion(T) qui effectue le tri de la liste T par insertion, en suivant l'algorithme vu en cours et en utilisant la fonction insere() . Puis testez-la avec les jeux de tests en dessous. def tri_insertion(T) : # \u00e0 remplir for i in range(1,len(T)) : insere(T,i) return T Tester cette fonction tri_insertion(T) sur la liste L suivante. L = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] # test de la fonction tri_insertion print(tri_insertion(L)) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25] Quelle est la complexit\u00e9 de l'algorithme de tri par insertion Essayons de mesurer la dur\u00e9e d'un tri par insertion. On fait varier la taille n de la liste T de 0 \u00e0 5000 et on stocke dans une liste les dur\u00e9es d'ex\u00e9cution de la fonction tri_insertion(T) en milliseconde, mesur\u00e9e \u00e0 l'aide la la fonction perfcounter() du module time, qui retourne un temps en secondes : X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [n-i for i in range(n)] debut = perf_counter() tri_insertion(T) fin = perf_counter() X.append(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) plt.show() On constate que l'ex\u00e9cution du script prend un temps significatif et, sur la courbe obtenue, qu'un doublement de la longueur de la liste, multiplie sa dur\u00e9e de tri par 4 ! En effet, comme pour le tri par s\u00e9lection, ce tri implique 2 boucles imbriqu\u00e9es : * la boucle for de la fonction tri_insertion() qui parcours la liste du d\u00e9but \u00e0 la fin * la boucle while de la fonction insere() qui parcourt les i premiers \u00e9l\u00e9ments de la liste (dans le pire des cas) $1 + 2 + 3 + ... + (n-2) + (n-1) = n * (n-1) / 2 = (n^2 - n) / 2$ comparaisons Vous pouvez copier le code de votre fonction insere() \u00e0 la place de son appel dans la fonction tri_insertion() pour mieux voir les boucles imbriqu\u00e9es. Ce qui confirme que ce tri par insertion est de **complexit\u00e9 quadtarique** $O(n^2)$. On a vu qu'une complexit\u00e9 quadratique n'est pas une solution efficace. Il existe d'autres algorithmes de tri plus performants, qui seront \u00e9tudi\u00e9s en classe de terminale. C'est le cas du tri fourni par Python dans la fonction sorted() : T = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] print(sorted(T)) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25] Evaluons son efficacit\u00e9 : X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [n-i for i in range(n)] debut = perf_counter() sorted(T) fin = perf_counter() X.append(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) plt.show() Le tri est quasiment instantan\u00e9, cette fonction \u00e0 une complexit\u00e9 de $O(n.log(n))$ dans le pire des cas. C'est actuellement la complexit\u00e9 la plus basse pour les algorithmes de tri, le tri de Python est donc optimal !","title":"TP"},{"location":"TP%20tris_correction/#nsi-specialite-nsi-premiere-jjdides-nov2021-sroux-janv2022","text":"","title":"NSI Sp\u00e9cialit\u00e9 NSI Premi\u00e8re - J.J.Dides nov.2021 - S.Roux janv.2022"},{"location":"TP%20tris_correction/#algorithmes-de-tris","text":"Dans ce notebook nous allons impl\u00e9menter en Python, les deux algorithmes de tris vus en cours : le tri par s\u00e9lection et le tri par insertion","title":"Algorithmes de tris"},{"location":"TP%20tris_correction/#tri-par-selection","text":"Le tri par s\u00e9lection parcours la liste de la gauche vers la droite, en maintenant sur la gauche une partie de la liste d\u00e9j\u00e0 tri\u00e9e et o\u00f9 les \u00e9l\u00e9ments sont rang\u00e9s \u00e0 leur place d\u00e9finitive. A chaque \u00e9tape, on cherche le plus petit \u00e9l\u00e9ment dans la partie de droite non tri\u00e9e de la liste, puis on l'\u00e9change avec l'\u00e9l\u00e9ment le plus \u00e0 gauche de cette partie non tri\u00e9e : Pour impl\u00e9menter en Python cet algorithme, nous allons nous aider de l'algorithme construit en cours et diviser les diff\u00e9rentes \u00e9tapes en plusieurs fonctions .","title":"Tri par S\u00e9lection"},{"location":"TP%20tris_correction/#application","text":"Ecrire une fonction minimum(T, a) qui retourne le rang du plus petit \u00e9l\u00e9ment de la liste T entre l'\u00e9l\u00e9ment d'indice a et le dernier \u00e9l\u00e9ment de la liste (inclus). Puis testez-la avec les listes cr\u00e9es ci-dessous def minimum(T, a) : # \u00e0 remplir if len(T) == 0 : return None imini = a for i in range(a+1,len(T)) : if T[i] < T[imini] : imini = i return imini # tests l1 = [3,2,9,6,8,1] l2 = [-2,0,5,7] l3 = [] print(minimum(l1,0)) print(minimum(l2,0)) print(minimum(l3,0)) 5 0 None","title":" &#9998; Application"},{"location":"TP%20tris_correction/#application_1","text":"Ecrire une fonction echange(T, a, b) qui permute dans la liste T les \u00e9l\u00e9ments d'indice a et b . Puis testez-la avec des nouvelles listes ou celles cr\u00e9es au-dessus. def echange(T, a, b) : # \u00e0 remplir T[a], T[b] = T[b], T[a] return T # tests print(echange(l1,0,5)) [1, 2, 9, 6, 8, 3]","title":" &#9998; Application"},{"location":"TP%20tris_correction/#application_2","text":"Ecrire maintenant la fonction tri_selection(T) qui effectue le tri de la liste T par s\u00e9lection, en suivant l'algorithme \u00e9crit dans le cours et en utilisant les 2 fonctions minimum() et echange() . def tri_selection(T) : # \u00e0 remplir for i in range(len(T)) : imini = minimum(T,i) echange(T,imini,i) return T Tester cette fonction sur la liste T suivante : # Soit la liste suivante (10 \u00e9l\u00e9ments entiers) \u00e0 trier T = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] tri_selection(T) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25]","title":" &#9998; Application"},{"location":"TP%20tris_correction/#quelle-est-la-complexite-de-lalgorithme-de-tri-par-selection","text":"Essayons de mesurer la dur\u00e9e d'un tri par s\u00e9lection. On fait varier la taille n de la liste T de 0 \u00e0 5000 et on stocke dans une liste les dur\u00e9es d'ex\u00e9cution de la fonction tri_selection(T) en milliseconde, mesur\u00e9es \u00e0 l'aide la la fonction perfcounter() du module time, qui retourne un temps en secondes : import matplotlib.pyplot as plt from time import perf_counter X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [i for i in range(2,n)] # cr\u00e9ation d'un tableau d\u00e9sordonn\u00e9 de n entiers T.append(1) debut = perf_counter() # mesure du temps avant et apr\u00e8s tri de T tri_selection(T) fin = perf_counter() X.append(n) # construction des listes des valeurs de n et T(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) # trac\u00e9 de la courbe de variation de T(n) en fonction de n plt.show() On constate, au premier abord que l'ex\u00e9cution du script prend un temps significatif. On observe ensuite, sur la courbe obtenue, qu'un doublement de la longueur du tableau, multiplie sa dur\u00e9e de tri par 4 ! Plus rigoureusement, pour \u00e9valuer la performance d'un algorithme de tri, on peut compter, par exemple, le nombre de comparaisons de 2 \u00e9l\u00e9ments de la liste. Si la liste comprend n \u00e9l\u00e9ments et que, dans le pire des cas, le d\u00e9sordre initial est total, il faudra, pour ordonner l'ensemble du tableau : $(n-1) + (n-2) + (n-3) + ... + 2 + 1 = n * (n-1) / 2 = n^2 / 2 - n / 2$ comparaisons En effet, ce tri implique 2 boucles imbriqu\u00e9es : * la boucle for de la fonction tri_selection() qui parcours la liste du d\u00e9but \u00e0 la fin (n it\u00e9rations) * la boucle for de la fonction minimum() qui recherche le minimum d'une liste de (n-i it\u00e9rations) Vous pouvez copier le code de votre fonction minimum() \u00e0 la place de son appel dans la fonction tri_selection() pour mieux voir les boucles imbriqu\u00e9es. Ce qui confirme que le tri par s\u00e9lection est de **complexit\u00e9 quadratique** $O(n^2)$ ! Pour rappel, voici les courbes des fonctions $f(n) = n$ (complexit\u00e9 lin\u00e9aire) et $f(n) = n^2$ (complexit\u00e9 quadratique) : X = [i for i in range(0,10)] YL = [i for i in range(0,10)] YQ = [i**2 for i in range(0,10)] plt.close() plt.plot(X, YL, YQ) plt.show()","title":"Quelle est la complexit\u00e9 de l'algorithme de tri par s\u00e9lection"},{"location":"TP%20tris_correction/#tri-par-insertion","text":"Le tri par insertion parcours lui aussi la liste de la gauche vers la droite, en construisant sur la gauche une partie de la liste d\u00e9j\u00e0 tri\u00e9e. On va, \u00e0 chaque \u00e9tape, ins\u00e9rer le premier \u00e9l\u00e9ment non encore tri\u00e9 parmi les \u00e9l\u00e9ments situ\u00e9s \u00e0 sa gauche et d\u00e9j\u00e0 tri\u00e9s. Les **slices** sont des expressions du langage Python qui vous permettent en une ligne de code d\u2019extraire des \u00e9l\u00e9ments d\u2019une liste ou d\u2019une cha\u00eene de caract\u00e8res. Exemples avec ``liste = [3,54,34,27,2,90]`` * ``liste[a:b]`` ==> correspond \u00e0 la sous-liste des \u00e9l\u00e9ments d'indice a \u00e0 b-1 * ``liste[0:3]`` ==> vaut ``[3, 54, 34]`` Pour impl\u00e9menter en Python cet algorithme : Il faut disposer d'une fonction insere(liste, i) qui ins\u00e8re l'\u00e9l\u00e9ment d'indice i ( liste[i] ) \u00e0 la bonne blace dans la liste tri\u00e9e liste[0:i] . Pour cela on compare liste[i] aux \u00e9l\u00e9ments tri\u00e9s de liste[0:i] qui le pr\u00e9c\u00e8dent. On rep\u00e8re le premier \u00e9l\u00e9ment liste[j] plus grand que liste[i] , d\u00e9caler les \u00e9l\u00e9ments de liste[j:i] plus grands que liste[i] d'une position vers la droite et placer liste[i] \u00e0 la position j ainsi lib\u00e9r\u00e9e. liste[i] sera d\u00e9plac\u00e9 \u00e0 une position qui conserve l'ordre croissant des \u00e9l\u00e9ments de liste[0:i+1]","title":"Tri par Insertion"},{"location":"TP%20tris_correction/#application_3","text":"Compl\u00e9ter la fonction insere(liste, i) qui ins\u00e8re l'\u00e9l\u00e9ment d'indice i \u00e0 la bonne blace dans la partie de liste tri\u00e9e. Cette fonction retourne la liste apr\u00e8s les modifications. Puis testez-la avec les jeux de tests en dessous. def insere(liste, i) : # tant que T[i] n'est pas \u00e0 la bonne place dans T[0:i], on echange sa valeur avec celle de l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent. while i > 0 and liste[i] < liste[i-1] : liste[i], liste[i-1] = liste[i-1], liste[i] i -= 1 return liste l2 = [0,3,4,5,2,9] assert insere(l2,4) == [0, 2, 3, 4, 5, 9] l3 = [4,5,6,8,9,0,1] assert insere(l3, 5) == [0, 4, 5, 6, 8, 9, 1] assert insere(l3, 6) == [0, 1, 4, 5, 6, 8, 9]","title":" &#9998; Application"},{"location":"TP%20tris_correction/#application_4","text":"Ecrire la fonction tri_insertion(T) qui effectue le tri de la liste T par insertion, en suivant l'algorithme vu en cours et en utilisant la fonction insere() . Puis testez-la avec les jeux de tests en dessous. def tri_insertion(T) : # \u00e0 remplir for i in range(1,len(T)) : insere(T,i) return T Tester cette fonction tri_insertion(T) sur la liste L suivante. L = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] # test de la fonction tri_insertion print(tri_insertion(L)) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25]","title":" &#9998; Application"},{"location":"TP%20tris_correction/#quelle-est-la-complexite-de-lalgorithme-de-tri-par-insertion","text":"Essayons de mesurer la dur\u00e9e d'un tri par insertion. On fait varier la taille n de la liste T de 0 \u00e0 5000 et on stocke dans une liste les dur\u00e9es d'ex\u00e9cution de la fonction tri_insertion(T) en milliseconde, mesur\u00e9e \u00e0 l'aide la la fonction perfcounter() du module time, qui retourne un temps en secondes : X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [n-i for i in range(n)] debut = perf_counter() tri_insertion(T) fin = perf_counter() X.append(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) plt.show() On constate que l'ex\u00e9cution du script prend un temps significatif et, sur la courbe obtenue, qu'un doublement de la longueur de la liste, multiplie sa dur\u00e9e de tri par 4 ! En effet, comme pour le tri par s\u00e9lection, ce tri implique 2 boucles imbriqu\u00e9es : * la boucle for de la fonction tri_insertion() qui parcours la liste du d\u00e9but \u00e0 la fin * la boucle while de la fonction insere() qui parcourt les i premiers \u00e9l\u00e9ments de la liste (dans le pire des cas) $1 + 2 + 3 + ... + (n-2) + (n-1) = n * (n-1) / 2 = (n^2 - n) / 2$ comparaisons Vous pouvez copier le code de votre fonction insere() \u00e0 la place de son appel dans la fonction tri_insertion() pour mieux voir les boucles imbriqu\u00e9es. Ce qui confirme que ce tri par insertion est de **complexit\u00e9 quadtarique** $O(n^2)$. On a vu qu'une complexit\u00e9 quadratique n'est pas une solution efficace. Il existe d'autres algorithmes de tri plus performants, qui seront \u00e9tudi\u00e9s en classe de terminale. C'est le cas du tri fourni par Python dans la fonction sorted() : T = [18, 3, 10, 25, 9, 5, 11, 13, 23, 8] print(sorted(T)) [3, 5, 8, 9, 10, 11, 13, 18, 23, 25] Evaluons son efficacit\u00e9 : X, Y = [], [] plt.close() for n in range(0, 5000, 500) : T = [n-i for i in range(n)] debut = perf_counter() sorted(T) fin = perf_counter() X.append(n) Y.append(1000*(fin-debut)) plt.plot(X, Y) plt.show() Le tri est quasiment instantan\u00e9, cette fonction \u00e0 une complexit\u00e9 de $O(n.log(n))$ dans le pire des cas. C'est actuellement la complexit\u00e9 la plus basse pour les algorithmes de tri, le tri de Python est donc optimal !","title":"Quelle est la complexit\u00e9 de l'algorithme de tri par insertion"},{"location":"algo/","text":"Algorithmes","title":"Algorithmes"},{"location":"algo/#algorithmes","text":"","title":"Algorithmes"},{"location":"types_bases/","text":"Repr\u00e9sentation des types de bases","title":"Repr\u00e9sentation des types de bases"},{"location":"types_bases/#representation-des-types-de-bases","text":"","title":"Repr\u00e9sentation des types de bases"},{"location":"types_bases/TP%20conversion%20bases/","text":"TP Python impl\u00e9mentation fonctions de conversion On cherche \u00e0 \u00e9crire 2 fonctions qui assurent * la conversion d\u2019un nombre entier d\u00e9cimal en binaire : dec2bin() * la conversion d\u2019un nombre entier binaire en d\u00e9cimal : bin2dec() En Python, le type int est affich\u00e9 en base 10 (exemple 42). Pour permettre son affichage en binaire, on peut construire la chaine de caract\u00e8re correspondante (exemple \u2018101010\u2019). M\u00eame chose en hexad\u00e9cimal (exemple \u20182A\u2019). Pour parcourir une chaine de caract\u00e8re, on peut utiliser une boucle for car in chaine : dans laquelle car prendra successivement la valeur de chacun des caract\u00e8res de chaine, et qui se r\u00e9p\u00e8tera autant de fois qu\u2019il y a de caract\u00e8res dans la chaine. Voici les algorithmes et sp\u00e9cifications de nos 2 fonctions : def dec2bin(dec): \"\"\" convertit un nombre entier d\u00e9cimal en nombre binaire # entr\u00e9e : dec, un nombre entier d\u00e9cimal # sortie : bin, une chaine de caract\u00e8res \u20180\u2019 et \u20181\u2019, la suite de chiffres du nombre binaire correspondant \u00e0 dec \"\"\" bin = \"\" tant que (dec non nul) r\u00e9p\u00e9ter : reste = reste de la division enti\u00e8re de dec par 2 concat\u00e9ner str(reste) + bin dec = quotient de la division enti\u00e8re de dec par 2 retourner bin def bin2dec(bin): \"\"\" convertit un nombre entier binaire en nombre d\u00e9cimal # entr\u00e9e : bin, une chaine de caract\u00e8res \u20180\u2019 et \u20181\u2019, la suite de chiffres d\u2019un nombre binaire # sortie : dec, un nombre entier d\u00e9cimal, correspondant \u00e0 bin \"\"\" dec = 0 pour chaque bit de bin r\u00e9p\u00e9ter : dec = dec * 2 + int(bit) retourner dec A partir de leur sp\u00e9cification et des algorithmes, impl\u00e9menter les 2 fonctions, les tester sur quelques exemples et tracer, sur un exemple simple, l\u2019ex\u00e9cution des boucles (un print \u00e0 chaque tour pour afficher le d\u00e9roulement). # fonctions ici","title":"TP"},{"location":"types_bases/TP%20conversion%20bases/#tp-python-implementation-fonctions-de-conversion","text":"On cherche \u00e0 \u00e9crire 2 fonctions qui assurent * la conversion d\u2019un nombre entier d\u00e9cimal en binaire : dec2bin() * la conversion d\u2019un nombre entier binaire en d\u00e9cimal : bin2dec() En Python, le type int est affich\u00e9 en base 10 (exemple 42). Pour permettre son affichage en binaire, on peut construire la chaine de caract\u00e8re correspondante (exemple \u2018101010\u2019). M\u00eame chose en hexad\u00e9cimal (exemple \u20182A\u2019). Pour parcourir une chaine de caract\u00e8re, on peut utiliser une boucle for car in chaine : dans laquelle car prendra successivement la valeur de chacun des caract\u00e8res de chaine, et qui se r\u00e9p\u00e8tera autant de fois qu\u2019il y a de caract\u00e8res dans la chaine. Voici les algorithmes et sp\u00e9cifications de nos 2 fonctions : def dec2bin(dec): \"\"\" convertit un nombre entier d\u00e9cimal en nombre binaire # entr\u00e9e : dec, un nombre entier d\u00e9cimal # sortie : bin, une chaine de caract\u00e8res \u20180\u2019 et \u20181\u2019, la suite de chiffres du nombre binaire correspondant \u00e0 dec \"\"\" bin = \"\" tant que (dec non nul) r\u00e9p\u00e9ter : reste = reste de la division enti\u00e8re de dec par 2 concat\u00e9ner str(reste) + bin dec = quotient de la division enti\u00e8re de dec par 2 retourner bin def bin2dec(bin): \"\"\" convertit un nombre entier binaire en nombre d\u00e9cimal # entr\u00e9e : bin, une chaine de caract\u00e8res \u20180\u2019 et \u20181\u2019, la suite de chiffres d\u2019un nombre binaire # sortie : dec, un nombre entier d\u00e9cimal, correspondant \u00e0 bin \"\"\" dec = 0 pour chaque bit de bin r\u00e9p\u00e9ter : dec = dec * 2 + int(bit) retourner dec A partir de leur sp\u00e9cification et des algorithmes, impl\u00e9menter les 2 fonctions, les tester sur quelques exemples et tracer, sur un exemple simple, l\u2019ex\u00e9cution des boucles (un print \u00e0 chaque tour pour afficher le d\u00e9roulement). # fonctions ici","title":"TP Python impl\u00e9mentation fonctions de conversion"},{"location":"types_bases/booleens/","text":"La logique bool\u00e9enne Un ordinateur est dot\u00e9 de circuits \u00e9lectroniques qui lui permettent de stocker des informations (la m\u00e9moire) et de faire des calculs (l\u2019unit\u00e9 arithm\u00e9tique et logique du processeur). Ces circuits \u00e9lectroniques fonctionnent avec deux niveaux de signal \u00e9lectronique : le courant passe (\u00ab1\u00bb ou \u00abvrai\u00bb) ou ne passe pas (\u00ab0\u00bb ou \u00abfaux\u00bb). On parle de logique binaire ou bool\u00e9enne , et l\u2019information v\u00e9hicul\u00e9e par le signal \u00e9lectrique est appel\u00e9e bit , abr\u00e9viation de l\u2019anglais binary digit . 1. Les op\u00e9rateurs de la logique bool\u00e9enne La logique binaire, ou logique bool\u00e9enne, a trois principaux op\u00e9rateurs pour manipuler les valeurs logiques Vrai et Faux : la n\u00e9gation (NOT) : soit A une valeur logique, NOT(A) (ou non A ) est vrai si A est faux et vice versa le et logique (AND) : soient A et B deux valeurs logiques, AND(A,B) (ou A et B ) est vrai si et seulement si A est vrai et B est vrai le ou logique (OR) : soient A et B deux valeurs logiques, OR(A,B) (ou A ou B ) est vrai si et seulement si A est vrai ou B est vrai, y compris si les deux sont vrais. Attention l'op\u00e9rateur OR est un \"ou inclusif\", \u00e0 ne pas confondre avec l'op\u00e9rateur XOR qui correpond au \"ou exclusif\" (fromage ou dessert, pas les deux). La table suivante est la table de v\u00e9rit\u00e9 de ces trois op\u00e9rateurs. Elle repr\u00e9sente le r\u00e9sultat de chaque op\u00e9rateur pour toutes les valeurs de v\u00e9rit\u00e9 des op\u00e9randes A et B : A B Non A Non B A ou B A et B Vrai Vrai Faux Faux Vrai Vrai Vrai Faux Faux Vrai Vrai Faux Faux Vrai Vrai Faux Vrai Faux Faux Faux Vrai Vrai Faux Faux Les op\u00e9rations en logique bool\u00e9ennes ont les propri\u00e9t\u00e9s importantes suivantes : Commutativit\u00e9 : A et B == B et A ; A ou B == B ou A. Associativit\u00e9 : A et (B et C) == (A et B) et C ; A ou (B ou C) == (A ou B) ou C. Distributivit\u00e9 : A et (B ou C) == (A et B) ou (A et C) ; A ou (B et C) == (A ou B) et (A ou C). Par contre, A et (B ou C) n\u2019est pas \u00e9quivalent \u00e0 (A et B) ou C. Elles v\u00e9rifient \u00e9galement les identit\u00e9s remarquables, appel\u00e9es Lois de De Morgan : non (A et B) == non A ou non B non (A ou B) == non A et non B Enfin, toutes les fonctions bool\u00e9ennes peuvent s\u2019exprimer avec une combinaison des op\u00e9rateurs ou, et et non. 2. Les circuits logiques binaires Les circuits int\u00e9gr\u00e9s des ordinateurs sont constitu\u00e9s de portes logiques (appel\u00e9s transistors) qui permettent de combiner des signaux binaires. Si l\u2019on convient que la pr\u00e9sence d\u2019un signal \u00e9lectrique repr\u00e9sente la valeur logique Vrai et son absence la valeur logique Faux, les portes logiques permettent de combiner ces signaux pour effectuer les op\u00e9rations de la logique bool\u00e9enne. Les portes logiques sont repr\u00e9sent\u00e9es conventionnellement par les sch\u00e9mas ci-dessous dans les circuits logiques. Non A A ou B A et B A xor B La combinaison des portes logiques permet de construire les composants de base d\u2019un ordinateur comme, par exemple, l\u2019addition de nombres binaires dans le processeur. Dans ce cas, les valeurs bool\u00e9ennes Vrai et Faux sont interpr\u00e9t\u00e9es comme 1 et 0. Dans le sch\u00e9ma ci-dessous, la sortie S est la somme des deux bits A et B, et R la retenue. Ainsi, si A vaut 1 et B vaut 1, la somme est 2, soit 10 en binaire, donc S vaut 0 et R vaut 1. 3. Les expressions logiques : \u00e9valuation \u00abcourt-circuit\u00bb Dans les langages de programmation comme Python, les valeurs de type bool\u00e9en (True et False) impl\u00e9mentent la logique bool\u00e9enne. Cependant, les op\u00e9rateurs tirent parti des propri\u00e9t\u00e9s suivantes qui permettent d\u2019acc\u00e9l\u00e9rer le calcul d\u2019expressions bool\u00e9ennes dans certains cas : Faux et B vaut Faux quelle que soit la valeur de B Vrai ou B vaut vrai quelle que soit la valeur de B Ainsi, si l\u2019on a une expression A et B et que l\u2019on a calcul\u00e9 que A est faux, le r\u00e9sultat est forc\u00e9ment faux et il n\u2019y a donc pas besoin de calculer B. De m\u00eame, si l\u2019on a une expression A ou B et que l\u2019on a calcul\u00e9 que A est vrai, le r\u00e9sultat est forc\u00e9ment vrai et on n\u2019a pas besoin de calculer B. On parle d\u2019\u00e9valuation court-circuit . Ainsi, bien que ces op\u00e9rateurs soient en principe commutatifs, l\u2019ordre des termes dans les expressions bool\u00e9ennes de Python a de l\u2019importance. Consid\u00e9rons l\u2019expression Python y/x > 0 and x != 0 et que x est nul, le calcul de y/x > 0 provoque une erreur de division par z\u00e9ro. Par contre, si l\u2019on \u00e9crit x != 0 and y/x > 0 . Si x est nul, x != 0 est faux et donc on n\u2019a pas besoin de calculer y/x > 0 , ce qui \u00e9vite de provoquer l'erreur de division par z\u00e9ro. L\u2019ordre d\u2019\u00e9valuation est donc important. En r\u00e9sum\u00e9, dans une expression conjonctive A and B and C and \u2026, la premi\u00e8re condition fausse arr\u00eate le calcul de l\u2019expression, qui vaut False. Dans une expression disjonctive A or B or C or \u2026, la premi\u00e8re condition vraie arr\u00eate le calcul de l\u2019expression, qui vaut True.","title":"Cours"},{"location":"types_bases/booleens/#la-logique-booleenne","text":"Un ordinateur est dot\u00e9 de circuits \u00e9lectroniques qui lui permettent de stocker des informations (la m\u00e9moire) et de faire des calculs (l\u2019unit\u00e9 arithm\u00e9tique et logique du processeur). Ces circuits \u00e9lectroniques fonctionnent avec deux niveaux de signal \u00e9lectronique : le courant passe (\u00ab1\u00bb ou \u00abvrai\u00bb) ou ne passe pas (\u00ab0\u00bb ou \u00abfaux\u00bb). On parle de logique binaire ou bool\u00e9enne , et l\u2019information v\u00e9hicul\u00e9e par le signal \u00e9lectrique est appel\u00e9e bit , abr\u00e9viation de l\u2019anglais binary digit .","title":"La logique bool\u00e9enne"},{"location":"types_bases/booleens/#1-les-operateurs-de-la-logique-booleenne","text":"La logique binaire, ou logique bool\u00e9enne, a trois principaux op\u00e9rateurs pour manipuler les valeurs logiques Vrai et Faux : la n\u00e9gation (NOT) : soit A une valeur logique, NOT(A) (ou non A ) est vrai si A est faux et vice versa le et logique (AND) : soient A et B deux valeurs logiques, AND(A,B) (ou A et B ) est vrai si et seulement si A est vrai et B est vrai le ou logique (OR) : soient A et B deux valeurs logiques, OR(A,B) (ou A ou B ) est vrai si et seulement si A est vrai ou B est vrai, y compris si les deux sont vrais. Attention l'op\u00e9rateur OR est un \"ou inclusif\", \u00e0 ne pas confondre avec l'op\u00e9rateur XOR qui correpond au \"ou exclusif\" (fromage ou dessert, pas les deux). La table suivante est la table de v\u00e9rit\u00e9 de ces trois op\u00e9rateurs. Elle repr\u00e9sente le r\u00e9sultat de chaque op\u00e9rateur pour toutes les valeurs de v\u00e9rit\u00e9 des op\u00e9randes A et B : A B Non A Non B A ou B A et B Vrai Vrai Faux Faux Vrai Vrai Vrai Faux Faux Vrai Vrai Faux Faux Vrai Vrai Faux Vrai Faux Faux Faux Vrai Vrai Faux Faux Les op\u00e9rations en logique bool\u00e9ennes ont les propri\u00e9t\u00e9s importantes suivantes : Commutativit\u00e9 : A et B == B et A ; A ou B == B ou A. Associativit\u00e9 : A et (B et C) == (A et B) et C ; A ou (B ou C) == (A ou B) ou C. Distributivit\u00e9 : A et (B ou C) == (A et B) ou (A et C) ; A ou (B et C) == (A ou B) et (A ou C). Par contre, A et (B ou C) n\u2019est pas \u00e9quivalent \u00e0 (A et B) ou C. Elles v\u00e9rifient \u00e9galement les identit\u00e9s remarquables, appel\u00e9es Lois de De Morgan : non (A et B) == non A ou non B non (A ou B) == non A et non B Enfin, toutes les fonctions bool\u00e9ennes peuvent s\u2019exprimer avec une combinaison des op\u00e9rateurs ou, et et non.","title":"1. Les op\u00e9rateurs de la logique bool\u00e9enne"},{"location":"types_bases/booleens/#2-les-circuits-logiques-binaires","text":"Les circuits int\u00e9gr\u00e9s des ordinateurs sont constitu\u00e9s de portes logiques (appel\u00e9s transistors) qui permettent de combiner des signaux binaires. Si l\u2019on convient que la pr\u00e9sence d\u2019un signal \u00e9lectrique repr\u00e9sente la valeur logique Vrai et son absence la valeur logique Faux, les portes logiques permettent de combiner ces signaux pour effectuer les op\u00e9rations de la logique bool\u00e9enne. Les portes logiques sont repr\u00e9sent\u00e9es conventionnellement par les sch\u00e9mas ci-dessous dans les circuits logiques. Non A A ou B A et B A xor B La combinaison des portes logiques permet de construire les composants de base d\u2019un ordinateur comme, par exemple, l\u2019addition de nombres binaires dans le processeur. Dans ce cas, les valeurs bool\u00e9ennes Vrai et Faux sont interpr\u00e9t\u00e9es comme 1 et 0. Dans le sch\u00e9ma ci-dessous, la sortie S est la somme des deux bits A et B, et R la retenue. Ainsi, si A vaut 1 et B vaut 1, la somme est 2, soit 10 en binaire, donc S vaut 0 et R vaut 1.","title":"2. Les circuits logiques binaires"},{"location":"types_bases/booleens/#3-les-expressions-logiques-evaluation-court-circuit","text":"Dans les langages de programmation comme Python, les valeurs de type bool\u00e9en (True et False) impl\u00e9mentent la logique bool\u00e9enne. Cependant, les op\u00e9rateurs tirent parti des propri\u00e9t\u00e9s suivantes qui permettent d\u2019acc\u00e9l\u00e9rer le calcul d\u2019expressions bool\u00e9ennes dans certains cas : Faux et B vaut Faux quelle que soit la valeur de B Vrai ou B vaut vrai quelle que soit la valeur de B Ainsi, si l\u2019on a une expression A et B et que l\u2019on a calcul\u00e9 que A est faux, le r\u00e9sultat est forc\u00e9ment faux et il n\u2019y a donc pas besoin de calculer B. De m\u00eame, si l\u2019on a une expression A ou B et que l\u2019on a calcul\u00e9 que A est vrai, le r\u00e9sultat est forc\u00e9ment vrai et on n\u2019a pas besoin de calculer B. On parle d\u2019\u00e9valuation court-circuit . Ainsi, bien que ces op\u00e9rateurs soient en principe commutatifs, l\u2019ordre des termes dans les expressions bool\u00e9ennes de Python a de l\u2019importance. Consid\u00e9rons l\u2019expression Python y/x > 0 and x != 0 et que x est nul, le calcul de y/x > 0 provoque une erreur de division par z\u00e9ro. Par contre, si l\u2019on \u00e9crit x != 0 and y/x > 0 . Si x est nul, x != 0 est faux et donc on n\u2019a pas besoin de calculer y/x > 0 , ce qui \u00e9vite de provoquer l'erreur de division par z\u00e9ro. L\u2019ordre d\u2019\u00e9valuation est donc important. En r\u00e9sum\u00e9, dans une expression conjonctive A and B and C and \u2026, la premi\u00e8re condition fausse arr\u00eate le calcul de l\u2019expression, qui vaut False. Dans une expression disjonctive A or B or C or \u2026, la premi\u00e8re condition vraie arr\u00eate le calcul de l\u2019expression, qui vaut True.","title":"3. Les expressions logiques : \u00e9valuation \u00abcourt-circuit\u00bb"}]}